# CardsShop

# Диаграмма классов
``` mermaid
classDiagram
    class Пользователь {
        -id: int
        -имя: string
        -email: string
        -пароль: string
        -роль: string (Покупатель/Админ)
        +регистрация()
        +авторизация()
        +изменитьПрофиль()
    }

    class Видеокарта {
        -id: int
        -модель: string
        -производитель: string (NVIDIA/AMD)
        -цена: decimal
        -количество: int
        -характеристики: JSON (VRAM, частота, TDP)
        +добавитьВКаталог()
        +обновитьДанные()
        +удалитьИзКаталога()
    }

    class Корзина {
        -id: int
        -userId: int
        -товары: Видеокарта[]
        +добавитьТовар()
        +удалитьТовар()
        +очистить()
        +рассчитатьИтог()
    }

    class Заказ {
        -id: int
        -дата: DateTime
        -статус: string (Оформлен/Оплачен/Доставлен)
        -сумма: decimal
        -адресДоставки: string
        +создать()
        +отменить()
        +обновитьСтатус()
    }

    class Отзыв {
        -id: int
        -userId: int
        -видеокартаId: int
        -текст: string
        -рейтинг: int (1-5)
        +добавитьОтзыв()
        +удалитьОтзыв()
    }

    class Категория {
        -id: int
        -название: string (Игровые/Майнинг/Профессиональные)
        -описание: string
        +добавитьКатегорию()
        +изменитьКатегорию()
    }

    class Платеж {
        -id: int
        -заказId: int
        -способ: string (Карта/Крипто)
        -статус: string (Ожидание/Успех/Ошибка)
        +провестиПлатеж()
        +вернутьДеньги()
    }

    Пользователь "1" --> "0..*" Корзина
    Пользователь "1" --> "0..*" Заказ
    Пользователь "1" --> "0..*" Отзыв
    Корзина "1" --> "1..*" Видеокарта
    Заказ "1" --> "1..*" Видеокарта
    Видеокарта "1" --> "0..*" Отзыв
    Видеокарта "n" --> "1..m" Категория
    Заказ "1" --> "1" Платеж
```
Назначение: Отображает статическую структуру системы, основные сущности и их взаимосвязи.

Решаемая проблема:

Четкое определение ключевых объектов системы (например, товар, заказ, пользователь) и их атрибутов.

Устранение неоднозначностей в понимании структуры данных между разработчиками.

Ключевые аспекты:

Показаны 7+ классов с атрибутами (например, Видеокарта: цена, количество, модель) и методами (добавитьВКаталог()).

Типы связей: композиция (Заказ → Платеж), агрегация (Корзина → Видеокарта).

Польза для архитектуры:

Служит основой для проектирования базы данных (таблицы, поля, связи).

Помогает избежать дублирования кода (например, общие методы для Пользователя и Администратора).

# Диаграмма вариантов использования
```mermaid
useCaseDiagram
    title Use Case Diagram: Онлайн-магазин видеокарт
    left-to-right direction
    
    actor Guest as "Гость"
    actor Customer as "Покупатель"
    actor Admin as "Администратор"
    
    "Гость" --> (Browse Catalog) : "Просмотр каталога"
    "Гость" --> (Search Products) : "Поиск товаров"
    "Гость" --> (Register) : "Регистрация"
    
    "Покупатель" --> (Login) : "Авторизация"
    "Покупатель" --> (Manage Cart) : "Управление корзиной"
    "Покупатель" --> (Checkout) : "Оформление заказа"
    "Покупатель" --> (Write Review) : "Написание отзывов"
    
    "Администратор" --> (Manage Products) : "Управление товарами"
    "Администратор" --> (View Analytics) : "Аналитика продаж"
    
    note right of "Администратор"
        Может выполнять все действия Покупателя
    end note
    
    (Checkout) .> (Process Payment) : includes
    (Manage Cart) .> (Browse Catalog) : extends
```

Назначение: Описывает функциональные возможности системы с точки зрения пользователей.

Решаемая проблема:

Определение границ системы: что могут делать гости, покупатели, админы.

Планирование интерфейсов (например, скрыть кнопку «Оплата» для гостей).

Ключевые аспекты:

Use cases: Просмотр каталога, Оформление заказа, Модерация отзывов.

Связи между актерами: обобщение (Админ → Покупатель).

Польза для архитектуры:

Помогает проектировать ролевую модель (например, права доступа в API).

Упрощает создание пользовательских сценариев для тестирования.

# Диаграмма Последовательностей
```mermaid
sequenceDiagram
    actor Покупатель as User
    participant Корзина as Cart
    participant Заказ as Order
    participant Платеж as Payment
    participant Видеокарта as GPU
    participant Система_оповещения as Notification

    User ->> Cart: Добавить видеокарту (GPU_ID)
    Cart ->> GPU: Проверить наличие (GPU_ID)
    GPU -->> Cart: Подтверждение (цена, количество)
    Cart -->> User: Товар добавлен

    User ->> Order: Оформить заказ (адрес доставки)
    Order ->> Cart: Получить список товаров
    Cart -->> Order: Данные товаров
    Order ->> Payment: Создать платеж (сумма)
    Payment -->> Order: Ссылка на оплату
    Order -->> User: Запрос оплаты

    User ->> Payment: Оплатить (карта/крипто)
    Payment ->> Order: Подтвердить оплату
    Order ->> GPU: Уменьшить количество (GPU_ID)
    Order ->> Notification: Уведомить о заказе
    Notification -->> User: Email/SMS
    Order -->> User: Заказ завершен (номер)
```
Назначение: Визуализирует взаимодействие объектов в рамках сценария «Оформление заказа».

Решаемая проблема:

Определение порядка действий при критичных процессах (оплата, резервирование товара).

Выявление «узких мест» (например, проверка наличия товара перед оплатой).

Ключевые аспекты:

Последовательность шагов: от добавления в корзину до уведомления пользователя.

Участвующие объекты: Покупатель, Корзина, Платеж, Видеокарта.

Польза для архитектуры:

Позволяет оптимизировать вызовы методов (например, объединить запросы к БД).

Выявляет необходимость транзакций (например, откат при ошибке оплаты).

# Функциональность

-   **Управление видеокартами**:

    -   Добавление новых моделей

    -   Редактирование параметров

    -   Удаление из каталога

    -   Поиск по названию

-   **Работа с производителями**:

    -   Просмотр списка производителей

    -   Связь видеокарт с производителями

-   **Администрирование**:

    -   Инициализация базы данных

    -   Выполнение SQL-скриптов

# Архитектура системы

Система построена по многослойной архитектуре:

1.  **Слой представления (UI)**:

    -   Консольный интерфейс (ConsoleUI.cs)

2.  **Бизнес-слой**:

    -   VideoCardService

    -   ManufacturerService

3.  **Слой доступа к данным**:

    -   VideoCardRepository

    -   ManufacturerRepository

4.  **Модели данных**:

    -   VideoCard

    -   Manufacturer

# База данных

**СУБД**: SQLite

**Таблицы**:

1.  Manufacturers - производители видеокарт

2.  GPUs - графические процессоры

3.  VideoCards - основные данные о видеокартах

4.  Shops - магазины

5.  Stocks - остатки на складах

6.  Customers - клиенты

7.  Orders - заказы

8.  OrderItems - позиции заказов

**Связи**:

-   Один-ко-многим:

    -   Производитель → Видеокарты

    -   GPU → Видеокарты

    -   Магазин → Остатки

    -   Клиент → Заказы

**Ключи**:

-   Первичные ключи: ManufacturerID, GPUID, VideoCardID и др.

-   Внешние ключи: ManufacturerID в VideoCards, GPUID в VideoCards

## Бизнес-логика

### **Основные правила:**

1.  **Валидация данных**:

    -   Цена видеокарты должна быть положительной

    -   Частоты (ядро/буст) должны быть положительными

    -   Название модели не может быть пустым

    -   Производитель должен существовать

2.  **Ограничения**:

    -   Удаление только существующих видеокарт

    -   Обновление только существующих записей

3.  **Процессы**:

    -   Автоматическое назначение ID при добавлении

    -   Частичный поиск по названию

    -   Полнотекстовый вывод информации

### **Особенности реализации:**

-   Использование интерфейсов для сервисов

-   Инкапсуляция бизнес-правил в сервисах

-   Централизованная обработка ошибок

-   Логирование операций
